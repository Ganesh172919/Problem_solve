/**
 * @module aiDrivenDocumentation
 * @description AI-driven documentation generation engine implementing automatic API
 * documentation synthesis, code comment enrichment, changelog generation from git
 * diffs, architecture diagram descriptors, runbook authoring, search-optimized
 * content organization, multi-format export (Markdown/OpenAPI/HTML), version-aware
 * doc management, staleness detection, cross-reference linking, and continuous
 * documentation quality scoring for developer-first engineering teams.
 */

import { getLogger } from './logger';

const logger = getLogger();

// â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type DocType = 'api_reference' | 'runbook' | 'architecture' | 'changelog' | 'tutorial' | 'faq' | 'adr' | 'glossary';
export type DocStatus = 'draft' | 'review' | 'published' | 'archived' | 'stale';
export type DocFormat = 'markdown' | 'html' | 'openapi' | 'asyncapi' | 'mermaid' | 'plantuml';
export type ChangelogType = 'feature' | 'bugfix' | 'breaking_change' | 'deprecation' | 'security' | 'performance' | 'refactor';

export interface DocPage {
  id: string;
  title: string;
  slug: string;
  type: DocType;
  status: DocStatus;
  content: string;
  format: DocFormat;
  version: number;
  tenantId: string;
  serviceId?: string;
  tags: string[];
  author: string;
  reviewers: string[];
  relatedPageIds: string[];
  qualityScore: number;
  readingTimeMinutes: number;
  wordCount: number;
  codeBlockCount: number;
  lastGeneratedAt?: number;
  isAutoGenerated: boolean;
  sourceFiles?: string[];
  createdAt: number;
  updatedAt: number;
  publishedAt?: number;
  expiresAt?: number;
}

export interface ApiEndpointDoc {
  path: string;
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  summary: string;
  description: string;
  tags: string[];
  parameters: ApiParameter[];
  requestBody?: ApiBodySpec;
  responses: Record<string, ApiResponseSpec>;
  security: string[];
  examples: ApiExample[];
  deprecated: boolean;
  since: string;
  xRateLimit?: string;
}

export interface ApiParameter {
  name: string;
  in: 'path' | 'query' | 'header' | 'cookie';
  required: boolean;
  type: string;
  format?: string;
  description: string;
  example?: unknown;
  enum?: unknown[];
}

export interface ApiBodySpec {
  required: boolean;
  contentType: string;
  schema: Record<string, unknown>;
  examples: Record<string, unknown>;
}

export interface ApiResponseSpec {
  description: string;
  contentType?: string;
  schema?: Record<string, unknown>;
  examples?: Record<string, unknown>;
}

export interface ApiExample {
  title: string;
  description: string;
  request: string;
  response: string;
  language: string;
}

export interface ChangelogEntry {
  id: string;
  version: string;
  releaseDate: number;
  type: ChangelogType;
  title: string;
  description: string;
  breaking: boolean;
  migrationGuide?: string;
  linkedPrNumber?: number;
  linkedIssueNumber?: number;
  author: string;
  serviceId?: string;
  tenantId: string;
}

export interface Runbook {
  id: string;
  title: string;
  description: string;
  serviceName: string;
  tenantId: string;
  tags: string[];
  triggerConditions: string[];
  steps: RunbookStep[];
  estimatedDurationMinutes: number;
  onCallRole: string;
  escalationPath: string[];
  relatedAlerts: string[];
  createdAt: number;
  updatedAt: number;
  lastReviewedAt: number;
}

export interface RunbookStep {
  order: number;
  title: string;
  description: string;
  commands?: string[];
  checkpoints: string[];
  rollbackInstructions?: string;
  automatable: boolean;
  automationScript?: string;
}

export interface ArchitectureDoc {
  id: string;
  serviceName: string;
  tenantId: string;
  description: string;
  components: ArchitectureComponent[];
  dataFlows: DataFlow[];
  externalDependencies: string[];
  deploymentModel: string;
  scalingStrategy: string;
  securityBoundaries: string[];
  diagramMermaid: string;
  updatedAt: number;
}

export interface ArchitectureComponent {
  id: string;
  name: string;
  type: 'service' | 'database' | 'cache' | 'queue' | 'gateway' | 'cdn' | 'external';
  technology: string;
  description: string;
  responsibilities: string[];
  interfaces: string[];
}

export interface DataFlow {
  from: string;
  to: string;
  protocol: string;
  dataType: string;
  syncAsync: 'sync' | 'async';
  encrypted: boolean;
}

export interface DocQualityReport {
  pageId: string;
  overallScore: number;
  freshness: number;
  completeness: number;
  clarity: number;
  codeQuality: number;
  crossLinkDensity: number;
  missingExamples: boolean;
  brokenLinks: string[];
  outdatedReferences: string[];
  suggestions: string[];
  generatedAt: number;
}

export interface SearchResult {
  pageId: string;
  title: string;
  snippet: string;
  relevanceScore: number;
  type: DocType;
  lastUpdated: number;
}

// â”€â”€ Engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class AIDrivenDocumentation {
  private readonly pages = new Map<string, DocPage>();
  private readonly endpointDocs = new Map<string, ApiEndpointDoc[]>();
  private readonly changelogs = new Map<string, ChangelogEntry[]>();
  private readonly runbooks = new Map<string, Runbook>();
  private readonly architectureDocs = new Map<string, ArchitectureDoc>();
  private readonly qualityReports = new Map<string, DocQualityReport>();
  private readonly searchIndex = new Map<string, string>(); // pageId â†’ searchable text

  // â”€â”€ Page Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  createPage(input: Omit<DocPage, 'id' | 'version' | 'qualityScore' | 'readingTimeMinutes' | 'wordCount' | 'codeBlockCount' | 'createdAt' | 'updatedAt'>): DocPage {
    const id = `doc-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const wordCount = input.content.split(/\s+/).filter(Boolean).length;
    const codeBlockCount = (input.content.match(/```/g) ?? []).length / 2;
    const page: DocPage = {
      ...input,
      id,
      version: 1,
      qualityScore: this.scoreContent(input.content),
      readingTimeMinutes: Math.ceil(wordCount / 200),
      wordCount,
      codeBlockCount: Math.floor(codeBlockCount),
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    this.pages.set(id, page);
    this.indexPage(page);
    logger.info('Documentation page created', { pageId: id, title: input.title, type: input.type });
    return page;
  }

  updatePage(id: string, updates: Partial<Omit<DocPage, 'id' | 'createdAt'>>): DocPage {
    const page = this.pages.get(id);
    if (!page) throw new Error(`Page ${id} not found`);
    const content = updates.content ?? page.content;
    const wordCount = content.split(/\s+/).filter(Boolean).length;
    const codeBlockCount = Math.floor((content.match(/```/g) ?? []).length / 2);
    Object.assign(page, updates, {
      version: page.version + 1,
      wordCount,
      codeBlockCount,
      qualityScore: this.scoreContent(content),
      readingTimeMinutes: Math.ceil(wordCount / 200),
      updatedAt: Date.now(),
    });
    this.indexPage(page);
    return page;
  }

  publishPage(id: string): DocPage {
    return this.updatePage(id, { status: 'published', publishedAt: Date.now() });
  }

  archivePage(id: string): DocPage {
    return this.updatePage(id, { status: 'archived' });
  }

  private indexPage(page: DocPage): void {
    this.searchIndex.set(page.id, `${page.title} ${page.content} ${page.tags.join(' ')}`);
  }

  // â”€â”€ Auto-Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  generateApiDocPage(tenantId: string, serviceId: string, endpoints: ApiEndpointDoc[]): DocPage {
    this.endpointDocs.set(`${tenantId}:${serviceId}`, endpoints);

    const content = this.renderApiDocMarkdown(serviceId, endpoints);
    return this.createPage({
      title: `${serviceId} API Reference`,
      slug: `api/${serviceId.toLowerCase().replace(/\s+/g, '-')}`,
      type: 'api_reference',
      status: 'published',
      content,
      format: 'markdown',
      tenantId,
      serviceId,
      tags: ['api', 'reference', serviceId],
      author: 'system',
      reviewers: [],
      relatedPageIds: [],
      isAutoGenerated: true,
      sourceFiles: [`src/app/api/${serviceId}/route.ts`],
      lastGeneratedAt: Date.now(),
    });
  }

  private renderApiDocMarkdown(serviceId: string, endpoints: ApiEndpointDoc[]): string {
    const lines: string[] = [
      `# ${serviceId} API Reference`,
      '',
      `> Auto-generated documentation. Last updated: ${new Date().toISOString()}`,
      '',
    ];

    for (const ep of endpoints) {
      lines.push(`## \`${ep.method} ${ep.path}\``);
      if (ep.deprecated) lines.push('> âš ï¸ **Deprecated** â€” use the newer API version.');
      lines.push('');
      lines.push(ep.summary);
      lines.push('');
      lines.push(ep.description);
      lines.push('');

      if (ep.parameters.length > 0) {
        lines.push('### Parameters');
        lines.push('');
        lines.push('| Name | In | Required | Type | Description |');
        lines.push('|------|----|----------|------|-------------|');
        for (const p of ep.parameters) {
          lines.push(`| \`${p.name}\` | ${p.in} | ${p.required ? 'Yes' : 'No'} | ${p.type} | ${p.description} |`);
        }
        lines.push('');
      }

      if (ep.requestBody) {
        lines.push('### Request Body');
        lines.push('');
        lines.push('```json');
        lines.push(JSON.stringify(ep.requestBody.schema, null, 2));
        lines.push('```');
        lines.push('');
      }

      lines.push('### Responses');
      lines.push('');
      for (const [code, resp] of Object.entries(ep.responses)) {
        lines.push(`**\`${code}\`** â€” ${resp.description}`);
        if (resp.schema) {
          lines.push('');
          lines.push('```json');
          lines.push(JSON.stringify(resp.schema, null, 2));
          lines.push('```');
        }
        lines.push('');
      }

      if (ep.examples.length > 0) {
        lines.push('### Examples');
        lines.push('');
        for (const ex of ep.examples.slice(0, 2)) {
          lines.push(`#### ${ex.title}`);
          lines.push(ex.description);
          lines.push('');
          lines.push(`\`\`\`${ex.language}`);
          lines.push(ex.request);
          lines.push('```');
          lines.push('');
        }
      }

      lines.push('---');
      lines.push('');
    }

    return lines.join('\n');
  }

  generateOpenAPISpec(tenantId: string, serviceId: string): Record<string, unknown> {
    const endpoints = this.endpointDocs.get(`${tenantId}:${serviceId}`) ?? [];
    const paths: Record<string, unknown> = {};

    for (const ep of endpoints) {
      if (!paths[ep.path]) paths[ep.path] = {};
      (paths[ep.path] as Record<string, unknown>)[ep.method.toLowerCase()] = {
        summary: ep.summary,
        description: ep.description,
        tags: ep.tags,
        deprecated: ep.deprecated,
        parameters: ep.parameters.map(p => ({
          name: p.name,
          in: p.in,
          required: p.required,
          schema: { type: p.type, format: p.format, enum: p.enum },
          description: p.description,
        })),
        requestBody: ep.requestBody ? {
          required: ep.requestBody.required,
          content: { [ep.requestBody.contentType]: { schema: ep.requestBody.schema } },
        } : undefined,
        responses: Object.fromEntries(Object.entries(ep.responses).map(([code, resp]) => [
          code,
          { description: resp.description, content: resp.contentType ? { [resp.contentType]: { schema: resp.schema } } : undefined },
        ])),
      };
    }

    return {
      openapi: '3.1.0',
      info: { title: `${serviceId} API`, version: '1.0.0', description: `OpenAPI spec for ${serviceId}` },
      paths,
    };
  }

  generateChangelog(tenantId: string, serviceId: string, entries: Omit<ChangelogEntry, 'id' | 'tenantId'>[]): DocPage {
    const key = `${tenantId}:${serviceId}`;
    if (!this.changelogs.has(key)) this.changelogs.set(key, []);

    const enriched: ChangelogEntry[] = entries.map(e => ({
      ...e,
      id: `cl-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      tenantId,
    }));
    this.changelogs.get(key)!.push(...enriched);

    const content = this.renderChangelogMarkdown(serviceId, this.changelogs.get(key)!);
    return this.createPage({
      title: `${serviceId} Changelog`,
      slug: `changelog/${serviceId.toLowerCase().replace(/\s+/g, '-')}`,
      type: 'changelog',
      status: 'published',
      content,
      format: 'markdown',
      tenantId,
      serviceId,
      tags: ['changelog', serviceId],
      author: 'system',
      reviewers: [],
      relatedPageIds: [],
      isAutoGenerated: true,
      lastGeneratedAt: Date.now(),
    });
  }

  private renderChangelogMarkdown(serviceId: string, entries: ChangelogEntry[]): string {
    const lines = [`# ${serviceId} Changelog`, ''];
    const byVersion: Record<string, ChangelogEntry[]> = {};
    for (const e of entries) {
      if (!byVersion[e.version]) byVersion[e.version] = [];
      byVersion[e.version]!.push(e);
    }

    for (const [version, vEntries] of Object.entries(byVersion).sort().reverse()) {
      const date = new Date(vEntries[0]!.releaseDate).toISOString().split('T')[0];
      lines.push(`## [${version}] â€” ${date}`);
      lines.push('');
      for (const e of vEntries) {
        const prefix = e.breaking ? 'âš ï¸ **BREAKING** ' : '';
        const icon = { feature: 'âœ¨', bugfix: 'ðŸ›', breaking_change: 'ðŸ’¥', deprecation: 'âš¡', security: 'ðŸ”’', performance: 'ðŸš€', refactor: 'â™»ï¸' }[e.type] ?? '';
        lines.push(`- ${icon} ${prefix}${e.title}`);
        lines.push(`  ${e.description}`);
        if (e.migrationGuide) lines.push(`  > Migration: ${e.migrationGuide}`);
      }
      lines.push('');
    }
    return lines.join('\n');
  }

  generateRunbook(runbook: Omit<Runbook, 'id' | 'createdAt' | 'updatedAt' | 'lastReviewedAt'>): Runbook {
    const id = `rb-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const full: Runbook = {
      ...runbook,
      id,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      lastReviewedAt: Date.now(),
    };
    this.runbooks.set(id, full);

    // Also create a doc page for the runbook
    const content = this.renderRunbookMarkdown(full);
    this.createPage({
      title: full.title,
      slug: `runbooks/${full.title.toLowerCase().replace(/\s+/g, '-')}`,
      type: 'runbook',
      status: 'published',
      content,
      format: 'markdown',
      tenantId: full.tenantId,
      serviceId: full.serviceName,
      tags: ['runbook', ...full.tags],
      author: 'system',
      reviewers: [],
      relatedPageIds: [],
      isAutoGenerated: true,
      lastGeneratedAt: Date.now(),
    });
    return full;
  }

  private renderRunbookMarkdown(runbook: Runbook): string {
    const lines = [
      `# Runbook: ${runbook.title}`,
      '',
      `**Service:** ${runbook.serviceName}`,
      `**On-call Role:** ${runbook.onCallRole}`,
      `**Estimated Duration:** ${runbook.estimatedDurationMinutes} minutes`,
      '',
      '## Description',
      '',
      runbook.description,
      '',
      '## Trigger Conditions',
      '',
      ...runbook.triggerConditions.map(c => `- ${c}`),
      '',
      '## Escalation Path',
      '',
      ...runbook.escalationPath.map((e, i) => `${i + 1}. ${e}`),
      '',
      '## Steps',
      '',
    ];

    for (const step of runbook.steps.sort((a, b) => a.order - b.order)) {
      lines.push(`### Step ${step.order}: ${step.title}`);
      lines.push('');
      lines.push(step.description);
      lines.push('');
      if (step.commands && step.commands.length > 0) {
        lines.push('```bash');
        lines.push(...step.commands);
        lines.push('```');
        lines.push('');
      }
      if (step.checkpoints.length > 0) {
        lines.push('**Checkpoints:**');
        lines.push(...step.checkpoints.map(c => `- [ ] ${c}`));
        lines.push('');
      }
      if (step.rollbackInstructions) {
        lines.push(`> **Rollback:** ${step.rollbackInstructions}`);
        lines.push('');
      }
    }
    return lines.join('\n');
  }

  generateArchitectureDoc(doc: Omit<ArchitectureDoc, 'id' | 'updatedAt' | 'diagramMermaid'>): ArchitectureDoc {
    const id = `arch-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const diagramMermaid = this.generateMermaidDiagram(doc.components, doc.dataFlows);
    const full: ArchitectureDoc = { ...doc, id, diagramMermaid, updatedAt: Date.now() };
    this.architectureDocs.set(id, full);

    // Also create a doc page
    const content = this.renderArchitectureMarkdown(full);
    this.createPage({
      title: `${doc.serviceName} Architecture`,
      slug: `architecture/${doc.serviceName.toLowerCase().replace(/\s+/g, '-')}`,
      type: 'architecture',
      status: 'published',
      content,
      format: 'markdown',
      tenantId: doc.tenantId,
      serviceId: doc.serviceName,
      tags: ['architecture', doc.serviceName],
      author: 'system',
      reviewers: [],
      relatedPageIds: [],
      isAutoGenerated: true,
      lastGeneratedAt: Date.now(),
    });
    return full;
  }

  private generateMermaidDiagram(components: ArchitectureComponent[], flows: DataFlow[]): string {
    const lines = ['graph LR'];
    for (const c of components) {
      const shape = c.type === 'database' ? `[(${c.name})]` : c.type === 'queue' ? `{${c.name}}` : `[${c.name}]`;
      lines.push(`  ${c.id}${shape}`);
    }
    for (const f of flows) {
      const arrow = f.syncAsync === 'sync' ? '-->' : '-.->';
      lines.push(`  ${f.from} ${arrow}|${f.protocol}| ${f.to}`);
    }
    return lines.join('\n');
  }

  private renderArchitectureMarkdown(doc: ArchitectureDoc): string {
    const lines = [
      `# ${doc.serviceName} Architecture`,
      '',
      doc.description,
      '',
      '## Architecture Diagram',
      '',
      '```mermaid',
      doc.diagramMermaid,
      '```',
      '',
      '## Components',
      '',
      ...doc.components.map(c => [
        `### ${c.name} (${c.type})`,
        '',
        `**Technology:** ${c.technology}`,
        '',
        c.description,
        '',
        '**Responsibilities:**',
        ...c.responsibilities.map(r => `- ${r}`),
        '',
      ]).flat(),
      '## Deployment Model',
      '',
      doc.deploymentModel,
      '',
      '## Scaling Strategy',
      '',
      doc.scalingStrategy,
      '',
      '## Security Boundaries',
      '',
      ...doc.securityBoundaries.map(b => `- ${b}`),
    ];
    return lines.join('\n');
  }

  // â”€â”€ Quality Scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  private scoreContent(content: string): number {
    let score = 50;
    const words = content.split(/\s+/).filter(Boolean).length;
    if (words > 200) score += 10;
    if (words > 500) score += 10;
    if ((content.match(/```/g) ?? []).length >= 2) score += 10;
    if (content.includes('##')) score += 5;
    if (content.includes('|')) score += 5; // has table
    if (content.includes('> ')) score += 5; // has callout
    return Math.min(100, score);
  }

  auditQuality(pageId: string): DocQualityReport {
    const page = this.pages.get(pageId);
    if (!page) throw new Error(`Page ${pageId} not found`);

    const ageMs = Date.now() - page.updatedAt;
    const freshnessScore = Math.max(0, 100 - Math.floor(ageMs / 86_400_000) * 2);
    const completenessScore = page.wordCount > 300 ? 90 : page.wordCount > 100 ? 60 : 30;
    const codeQualityScore = page.codeBlockCount > 0 ? 80 : 40;
    const linkDensity = (page.relatedPageIds.length / Math.max(1, page.wordCount / 100)) * 100;

    const report: DocQualityReport = {
      pageId,
      overallScore: Math.round((freshnessScore + completenessScore + page.qualityScore + codeQualityScore) / 4),
      freshness: freshnessScore,
      completeness: completenessScore,
      clarity: page.qualityScore,
      codeQuality: codeQualityScore,
      crossLinkDensity: Math.min(100, linkDensity),
      missingExamples: page.codeBlockCount === 0 && page.type === 'api_reference',
      brokenLinks: [],
      outdatedReferences: ageMs > 90 * 86_400_000 ? ['Content may be outdated (>90 days old)'] : [],
      suggestions: this.buildQualitySuggestions(page, freshnessScore, completenessScore),
      generatedAt: Date.now(),
    };
    this.qualityReports.set(pageId, report);
    return report;
  }

  private buildQualitySuggestions(page: DocPage, freshness: number, completeness: number): string[] {
    const suggestions: string[] = [];
    if (freshness < 60) suggestions.push('Update content â€” last edited over 3 weeks ago');
    if (completeness < 50) suggestions.push('Expand content â€” consider adding more detail and context');
    if (page.codeBlockCount === 0) suggestions.push('Add code examples to improve developer experience');
    if (page.relatedPageIds.length < 2) suggestions.push('Link to related pages to improve navigation');
    if (!page.tags.length) suggestions.push('Add tags to improve discoverability');
    return suggestions;
  }

  // â”€â”€ Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  search(query: string, tenantId?: string, limit = 10): SearchResult[] {
    const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
    const results: SearchResult[] = [];

    for (const [pageId, text] of this.searchIndex) {
      const page = this.pages.get(pageId);
      if (!page) continue;
      if (tenantId && page.tenantId !== tenantId) continue;
      if (page.status !== 'published') continue;

      const normalizedText = text.toLowerCase();
      const matchCount = terms.filter(t => normalizedText.includes(t)).length;
      if (matchCount === 0) continue;

      const relevanceScore = matchCount / terms.length + (page.qualityScore / 100) * 0.3;
      const snippetStart = normalizedText.indexOf(terms[0] ?? '') - 50;
      const snippet = page.content.slice(Math.max(0, snippetStart), snippetStart + 150).trim();

      results.push({ pageId, title: page.title, snippet, relevanceScore, type: page.type, lastUpdated: page.updatedAt });
    }

    return results.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, limit);
  }

  // â”€â”€ Staleness Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  detectStalePages(tenantId: string, thresholdDays = 90): DocPage[] {
    const threshold = Date.now() - thresholdDays * 86_400_000;
    const stale = Array.from(this.pages.values()).filter(p =>
      p.tenantId === tenantId &&
      p.status === 'published' &&
      p.updatedAt < threshold
    );
    for (const p of stale) p.status = 'stale';
    return stale;
  }

  // â”€â”€ Queries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  getPage(id: string): DocPage | undefined { return this.pages.get(id); }
  listPages(tenantId?: string, type?: DocType, status?: DocStatus): DocPage[] {
    const all = Array.from(this.pages.values());
    return all.filter(p =>
      (!tenantId || p.tenantId === tenantId) &&
      (!type || p.type === type) &&
      (!status || p.status === status)
    );
  }
  getRunbook(id: string): Runbook | undefined { return this.runbooks.get(id); }
  listRunbooks(tenantId?: string): Runbook[] {
    const all = Array.from(this.runbooks.values());
    return tenantId ? all.filter(r => r.tenantId === tenantId) : all;
  }
  getQualityReport(pageId: string): DocQualityReport | undefined { return this.qualityReports.get(pageId); }
  getChangelogs(tenantId: string, serviceId: string): ChangelogEntry[] {
    return this.changelogs.get(`${tenantId}:${serviceId}`) ?? [];
  }
  getArchitectureDoc(id: string): ArchitectureDoc | undefined { return this.architectureDocs.get(id); }
  getOpenAPISpec(tenantId: string, serviceId: string): Record<string, unknown> {
    return this.generateOpenAPISpec(tenantId, serviceId);
  }

  getDashboardSummary() {
    const pages = Array.from(this.pages.values());
    return {
      totalPages: pages.length,
      publishedPages: pages.filter(p => p.status === 'published').length,
      stalePages: pages.filter(p => p.status === 'stale').length,
      autoGeneratedPages: pages.filter(p => p.isAutoGenerated).length,
      totalRunbooks: this.runbooks.size,
      totalArchitectureDocs: this.architectureDocs.size,
      avgQualityScore: pages.length > 0 ? Math.round(pages.reduce((s, p) => s + p.qualityScore, 0) / pages.length) : 0,
      totalWordCount: pages.reduce((s, p) => s + p.wordCount, 0),
      byType: pages.reduce((acc, p) => { acc[p.type] = (acc[p.type] ?? 0) + 1; return acc; }, {} as Record<string, number>),
    };
  }
}

// â”€â”€ Singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

declare global {
   
  var __aiDrivenDocumentation__: AIDrivenDocumentation | undefined;
}

export function getDocumentationEngine(): AIDrivenDocumentation {
  if (!globalThis.__aiDrivenDocumentation__) {
    globalThis.__aiDrivenDocumentation__ = new AIDrivenDocumentation();
  }
  return globalThis.__aiDrivenDocumentation__;
}

export { AIDrivenDocumentation };
