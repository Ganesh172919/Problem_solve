import { v4 as uuidv4 } from 'uuid';
import getDb from './index';
import { Post, PostRow } from '@/types';

function rowToPost(row: PostRow): Post {
  return {
    ...row,
    tags: JSON.parse(row.tags || '[]'),
    sourceReferences: JSON.parse(row.sourceReferences || '[]'),
    autoGenerated: row.autoGenerated === 1,
  };
}

export function getAllPosts(page = 1, limit = 10): { posts: Post[]; total: number } {
  const db = getDb();
  const offset = (page - 1) * limit;

  const totalRow = db.prepare('SELECT COUNT(*) as count FROM posts').get() as { count: number };
  const total = totalRow.count;

  const rows = db
    .prepare('SELECT * FROM posts ORDER BY createdAt DESC LIMIT ? OFFSET ?')
    .all(limit, offset) as PostRow[];

  return { posts: rows.map(rowToPost), total };
}

export function getPostBySlug(slug: string): Post | null {
  const db = getDb();
  const row = db.prepare('SELECT * FROM posts WHERE slug = ?').get(slug) as PostRow | undefined;
  return row ? rowToPost(row) : null;
}

export function getPostsByCategory(category: string, page = 1, limit = 10): { posts: Post[]; total: number } {
  const db = getDb();
  const offset = (page - 1) * limit;

  const totalRow = db
    .prepare('SELECT COUNT(*) as count FROM posts WHERE category = ?')
    .get(category) as { count: number };
  const total = totalRow.count;

  const rows = db
    .prepare('SELECT * FROM posts WHERE category = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?')
    .all(category, limit, offset) as PostRow[];

  return { posts: rows.map(rowToPost), total };
}

export function createPost(post: Omit<Post, 'id' | 'createdAt' | 'updatedAt'>): Post {
  const db = getDb();
  const id = uuidv4();
  const now = new Date().toISOString();

  db.prepare(`
    INSERT INTO posts (id, title, slug, content, summary, tags, category, metaDescription, createdAt, updatedAt, sourceReferences, autoGenerated)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    id,
    post.title,
    post.slug,
    post.content,
    post.summary,
    JSON.stringify(post.tags),
    post.category,
    post.metaDescription,
    now,
    now,
    JSON.stringify(post.sourceReferences),
    post.autoGenerated ? 1 : 0
  );

  // Keep FTS index in sync
  try {
    db.prepare(`INSERT INTO posts_fts(id, title, summary, tags) VALUES (?, ?, ?, ?)`)
      .run(id, post.title, post.summary, post.tags.join(' '));
  } catch {
    // FTS insert failure should not block post creation
  }

  return {
    ...post,
    id,
    createdAt: now,
    updatedAt: now,
  };
}

export function deletePost(id: string): boolean {
  const db = getDb();
  const result = db.prepare('DELETE FROM posts WHERE id = ?').run(id);
  if (result.changes > 0) {
    try {
      db.prepare("DELETE FROM posts_fts WHERE id = ?").run(id);
    } catch {
      // FTS delete failure is non-fatal
    }
  }
  return result.changes > 0;
}

export function slugExists(slug: string): boolean {
  const db = getDb();
  const row = db.prepare('SELECT 1 FROM posts WHERE slug = ?').get(slug);
  return !!row;
}

export function getRecentTopics(count = 10): string[] {
  const db = getDb();
  const rows = db
    .prepare('SELECT title FROM posts ORDER BY createdAt DESC LIMIT ?')
    .all(count) as { title: string }[];
  return rows.map((r) => r.title);
}

export function getPostStats() {
  const db = getDb();
  const total = (db.prepare('SELECT COUNT(*) as count FROM posts').get() as { count: number }).count;
  const autoCount = (
    db.prepare('SELECT COUNT(*) as count FROM posts WHERE autoGenerated = 1').get() as { count: number }
  ).count;
  const lastPost = db.prepare('SELECT createdAt FROM posts ORDER BY createdAt DESC LIMIT 1').get() as
    | { createdAt: string }
    | undefined;

  return {
    total,
    autoCount,
    lastGeneration: lastPost?.createdAt || null,
  };
}

export function getCategories(): string[] {
  const db = getDb();
  const rows = db
    .prepare('SELECT DISTINCT category FROM posts ORDER BY category')
    .all() as { category: string }[];
  return rows.map((r) => r.category);
}

export function searchPosts(
  query: string,
  page = 1,
  limit = 10,
): { posts: Post[]; total: number } {
  const db = getDb();
  const offset = (page - 1) * limit;
  const trimmed = query.trim();

  if (!trimmed) return getAllPosts(page, limit);

  try {
    // Use FTS5 for fast full-text search
    const ftsQuery = trimmed
      .split(/\s+/)
      .filter(Boolean)
      .map((w) => `"${w.replace(/"/g, '""')}"*`)
      .join(' OR ');

    const totalRow = db
      .prepare(`
        SELECT COUNT(*) as count FROM posts
        WHERE id IN (SELECT id FROM posts_fts WHERE posts_fts MATCH ?)
      `)
      .get(ftsQuery) as { count: number };

    const rows = db
      .prepare(`
        SELECT posts.* FROM posts
        JOIN posts_fts ON posts.id = posts_fts.id
        WHERE posts_fts MATCH ?
        ORDER BY rank
        LIMIT ? OFFSET ?
      `)
      .all(ftsQuery, limit, offset) as PostRow[];

    return { posts: rows.map(rowToPost), total: totalRow.count };
  } catch {
    // FTS not available or malformed query â€” fall back to LIKE search
    // Escape backslashes first, then LIKE wildcards (order matters)
    const escaped = trimmed
      .replace(/\\/g, '\\\\')
      .replace(/%/g, '\\%')
      .replace(/_/g, '\\_');
    const likeQuery = `%${escaped}%`;
    const totalRow = db
      .prepare('SELECT COUNT(*) as count FROM posts WHERE title LIKE ? OR summary LIKE ?')
      .get(likeQuery, likeQuery) as { count: number };

    const rows = db
      .prepare(
        'SELECT * FROM posts WHERE title LIKE ? OR summary LIKE ? ORDER BY createdAt DESC LIMIT ? OFFSET ?',
      )
      .all(likeQuery, likeQuery, limit, offset) as PostRow[];

    return { posts: rows.map(rowToPost), total: totalRow.count };
  }
}
