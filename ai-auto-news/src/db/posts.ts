import { v4 as uuidv4 } from 'uuid';
import getDb from './index';
import { Post, PostRow } from '@/types';

function rowToPost(row: PostRow): Post {
  return {
    ...row,
    tags: JSON.parse(row.tags || '[]'),
    sourceReferences: JSON.parse(row.sourceReferences || '[]'),
    autoGenerated: row.autoGenerated === 1,
  };
}

export function getAllPosts(page = 1, limit = 10): { posts: Post[]; total: number } {
  const db = getDb();
  const offset = (page - 1) * limit;

  const totalRow = db.prepare('SELECT COUNT(*) as count FROM posts').get() as { count: number };
  const total = totalRow.count;

  const rows = db
    .prepare('SELECT * FROM posts ORDER BY createdAt DESC LIMIT ? OFFSET ?')
    .all(limit, offset) as PostRow[];

  return { posts: rows.map(rowToPost), total };
}

export function getPostBySlug(slug: string): Post | null {
  const db = getDb();
  const row = db.prepare('SELECT * FROM posts WHERE slug = ?').get(slug) as PostRow | undefined;
  return row ? rowToPost(row) : null;
}

export function getPostsByCategory(category: string, page = 1, limit = 10): { posts: Post[]; total: number } {
  const db = getDb();
  const offset = (page - 1) * limit;

  const totalRow = db
    .prepare('SELECT COUNT(*) as count FROM posts WHERE category = ?')
    .get(category) as { count: number };
  const total = totalRow.count;

  const rows = db
    .prepare('SELECT * FROM posts WHERE category = ? ORDER BY createdAt DESC LIMIT ? OFFSET ?')
    .all(category, limit, offset) as PostRow[];

  return { posts: rows.map(rowToPost), total };
}

export function createPost(post: Omit<Post, 'id' | 'createdAt' | 'updatedAt'>): Post {
  const db = getDb();
  const id = uuidv4();
  const now = new Date().toISOString();

  db.prepare(`
    INSERT INTO posts (id, title, slug, content, summary, tags, category, metaDescription, createdAt, updatedAt, sourceReferences, autoGenerated)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(
    id,
    post.title,
    post.slug,
    post.content,
    post.summary,
    JSON.stringify(post.tags),
    post.category,
    post.metaDescription,
    now,
    now,
    JSON.stringify(post.sourceReferences),
    post.autoGenerated ? 1 : 0
  );

  return {
    ...post,
    id,
    createdAt: now,
    updatedAt: now,
  };
}

export function deletePost(id: string): boolean {
  const db = getDb();
  const result = db.prepare('DELETE FROM posts WHERE id = ?').run(id);
  return result.changes > 0;
}

export function slugExists(slug: string): boolean {
  const db = getDb();
  const row = db.prepare('SELECT 1 FROM posts WHERE slug = ?').get(slug);
  return !!row;
}

export function getRecentTopics(count = 10): string[] {
  const db = getDb();
  const rows = db
    .prepare('SELECT title FROM posts ORDER BY createdAt DESC LIMIT ?')
    .all(count) as { title: string }[];
  return rows.map((r) => r.title);
}

export function getPostStats() {
  const db = getDb();
  const total = (db.prepare('SELECT COUNT(*) as count FROM posts').get() as { count: number }).count;
  const autoCount = (
    db.prepare('SELECT COUNT(*) as count FROM posts WHERE autoGenerated = 1').get() as { count: number }
  ).count;
  const lastPost = db.prepare('SELECT createdAt FROM posts ORDER BY createdAt DESC LIMIT 1').get() as
    | { createdAt: string }
    | undefined;

  return {
    total,
    autoCount,
    lastGeneration: lastPost?.createdAt || null,
  };
}

export function getCategories(): string[] {
  const db = getDb();
  const rows = db
    .prepare('SELECT DISTINCT category FROM posts ORDER BY category')
    .all() as { category: string }[];
  return rows.map((r) => r.category);
}
