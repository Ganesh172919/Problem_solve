import { researchAgent } from './researchAgent';
import { blogAgent } from './blogAgent';
import { newsAgent } from './newsAgent';
import { formattingAgent } from './formattingAgent';
import { createPost, slugExists, getRecentTopics } from '@/db/posts';
import { trackAnalyticsEvent } from '@/db/analytics';
import { enqueueTask } from '@/db/tasks';
import { logger } from '@/lib/logger';
import { AgentTask, AgentStep } from '@/types/saas';
import { v4 as uuidv4 } from 'uuid';

const log = logger.child({ module: 'AgentOrchestrator' });

export type OrchestratorGoal =
  | { type: 'publish_content'; category?: 'blog' | 'news'; topic?: string }
  | { type: 'bulk_publish'; count: number; category?: 'blog' | 'news' }
  | { type: 'research_only'; topic?: string };

export interface OrchestratorResult {
  taskId: string;
  success: boolean;
  steps: AgentStep[];
  output: Record<string, unknown>;
  durationMs: number;
  error?: string;
}

function makeStep(name: string): AgentStep {
  return {
    id: uuidv4(),
    name,
    input: {},
    output: null,
    status: 'pending',
    durationMs: null,
  };
}

async function runStep<T>(
  step: AgentStep,
  input: Record<string, unknown>,
  fn: () => Promise<T>,
): Promise<T> {
  step.input = input;
  step.status = 'running';
  const start = Date.now();
  try {
    const result = await fn();
    step.output = result as Record<string, unknown>;
    step.status = 'done';
    step.durationMs = Date.now() - start;
    return result;
  } catch (e) {
    step.status = 'failed';
    step.durationMs = Date.now() - start;
    throw e;
  }
}

export async function orchestrate(goal: OrchestratorGoal): Promise<OrchestratorResult> {
  const taskId = uuidv4();
  const globalStart = Date.now();

  const agentTask: AgentTask = {
    id: taskId,
    goal: JSON.stringify(goal),
    steps: [],
    status: 'planning',
    result: null,
    createdAt: new Date().toISOString(),
    completedAt: null,
  };

  log.info('Orchestration started', { taskId, goal });

  try {
    if (goal.type === 'publish_content') {
      return await orchestratePublish(agentTask, goal, globalStart);
    } else if (goal.type === 'bulk_publish') {
      return await orchestrateBulkPublish(agentTask, goal, globalStart);
    } else if (goal.type === 'research_only') {
      return await orchestrateResearchOnly(agentTask, goal, globalStart);
    }
    throw new Error(`Unknown goal type: ${(goal as OrchestratorGoal).type}`);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    log.error('Orchestration failed', error instanceof Error ? error : undefined, { taskId });
    return {
      taskId,
      success: false,
      steps: agentTask.steps,
      output: {},
      durationMs: Date.now() - globalStart,
      error: message,
    };
  }
}

async function orchestratePublish(
  agentTask: AgentTask,
  goal: Extract<OrchestratorGoal, { type: 'publish_content' }>,
  globalStart: number,
): Promise<OrchestratorResult> {
  const stepResearch = makeStep('research');
  const stepGenerate = makeStep('generate_content');
  const stepFormat = makeStep('format_content');
  const stepPersist = makeStep('persist_post');
  agentTask.steps = [stepResearch, stepGenerate, stepFormat, stepPersist];

  // Step 1: Research
  const recentTopics = getRecentTopics(10);
  const research = await runStep(stepResearch, { recentTopics, requestedTopic: goal.topic }, () =>
    researchAgent(recentTopics),
  );

  if (!research.topic && !research.headline) {
    throw new Error('Research returned empty results');
  }

  // Step 2: Decide category and generate content
  const category = goal.category || (Math.random() > 0.4 ? 'blog' : 'news');
  const generated = await runStep(
    stepGenerate,
    { category, topic: research.topic },
    () => (category === 'blog' ? blogAgent(research) : newsAgent(research)),
  );

  if (!generated.title || !generated.content) {
    throw new Error('Content generation returned empty results');
  }

  // Step 3: Format
  const formattedContent = await runStep(
    stepFormat,
    { contentLength: generated.content.length },
    async () => ({ formatted: formattingAgent(generated.content) }),
  );

  // Step 4: Persist
  let slug = (generated.slug || generated.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '')).substring(0, 80);
  if (slugExists(slug)) slug = `${slug}-${Date.now()}`;

  const post = await runStep(stepPersist, { slug, category }, async () => {
    const saved = createPost({
      title: generated.title,
      slug,
      content: formattedContent.formatted,
      summary: generated.summary,
      tags: generated.tags,
      category,
      metaDescription: generated.metaDescription,
      sourceReferences: research.references,
      autoGenerated: true,
    });
    return saved as unknown as Record<string, unknown>;
  });

  trackAnalyticsEvent({
    userId: null,
    sessionId: null,
    eventName: 'generation.completed',
    properties: { category, postId: (post as Record<string, unknown>).id, title: generated.title },
    ipAddress: null,
    userAgent: null,
  });

  log.info('Orchestration completed', {
    taskId: agentTask.id,
    title: generated.title,
    category,
    durationMs: Date.now() - globalStart,
  });

  return {
    taskId: agentTask.id,
    success: true,
    steps: agentTask.steps,
    output: { post, category },
    durationMs: Date.now() - globalStart,
  };
}

async function orchestrateBulkPublish(
  agentTask: AgentTask,
  goal: Extract<OrchestratorGoal, { type: 'bulk_publish' }>,
  globalStart: number,
): Promise<OrchestratorResult> {
  const count = Math.min(goal.count, 10);
  const results: OrchestratorResult[] = [];

  for (let i = 0; i < count; i++) {
    // Enqueue each task to avoid overwhelming the AI APIs
    enqueueTask('publish_content', { category: goal.category, index: i });
  }

  log.info('Bulk publish enqueued', { count, taskId: agentTask.id });

  return {
    taskId: agentTask.id,
    success: true,
    steps: agentTask.steps,
    output: { enqueuedCount: count, results },
    durationMs: Date.now() - globalStart,
  };
}

async function orchestrateResearchOnly(
  agentTask: AgentTask,
  goal: Extract<OrchestratorGoal, { type: 'research_only' }>,
  globalStart: number,
): Promise<OrchestratorResult> {
  const stepResearch = makeStep('research');
  agentTask.steps = [stepResearch];

  const recentTopics = getRecentTopics(5);
  const research = await runStep(stepResearch, { recentTopics, requestedTopic: goal.topic }, () =>
    researchAgent(recentTopics),
  );

  return {
    taskId: agentTask.id,
    success: true,
    steps: agentTask.steps,
    output: { research },
    durationMs: Date.now() - globalStart,
  };
}
